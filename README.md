# 第四章 工厂模式

**工厂方法模式**：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

所谓的“决定”，并不是指模式允许子类本身在运行时做决定，而是指在编写创建者类时，不需要知道实际创建的产品是哪一个。选择了哪个子类，自然就决定了实际创建产品是什么

**OO设计原则（依赖倒置原则）**：要依赖抽象，不要依赖具体类。

不能让**高层组件**（由其他低层组件定义其行为的类）依赖**底层组件**，而且，不管高层组件或底层组件，两者都应该依赖于抽象。

**抽象工厂模式**：抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是什么。这样一来，客户就从具体产品中被解耦。

**工厂方法模式和抽象工厂模式都是将对象创建的过程封装起来，以便将客户代码从具体类中解耦。**



# 第五章 单件模式

**单件模式**：确保一个类只有一个实例，并提供一个全局访问点

**延迟实例化（lazy instantiaze）**：如果我们不需要这个实例，它就永远不会产生，即懒汉式

**处理多线程：**只要把getInstance()变成同步(synchronized)方法，多线程灾难几乎可以轻易解决。

**改善多线程**：

1.如果getInstance()的性能对应用程序不是很关键，就什么都别做。

2.使用"急切"创建实例，而不用延迟实例化的做法，即饿汉式。在私有静态初始化器中创建单件，保证了**线程安全**。

3.用”双重检查加锁“，在getInstance()中减少使用同步：利用双重检查加锁，首先检查是否实例已经创建了，如果尚未创建，“才”进行同步，这样一来，只有第一次才会同步。这个做法可以大大减少getInstance()的时间耗费。

violatile关键词确保：当uniqueInstance变量被初始化成Singleton实例时，多个线程正确的处理uniqueInstance变量。

# 第六章 命令模式

**命令模式**：将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也支持可撤销的操作。

# 第七章 适配器模式与外观模式

适配器将一个接口转换成另一个接口，以符合客户的期望。

适配器工作起来就如同一个中间人，它将客户所发出的请求转换成厂商类所能理解的请求。

**适配器模式：**将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。

应用：适配迭代器的枚举适配器EnumeratorIterator

**外观模式：**提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

外观模式没有封装子系统的类，外观只提供简化的接口。特征：提供简化接口的同时，依然将系统完整的功能暴露出来，以供需要的人使用。

**外观模式不只是简化了接口，也将客户从组件的子系统中解耦。**

外观模式和适配器模式可以包装一个类或许多类。

**外观与适配器区别是：外观的意图是为了简化接口，提供一个子系统的简化接口。而适配器的意图是将接口转换成不同的接口以满足客户期望。**

**OO设计原则 最少知识原则：只和你的密友谈话。**不要让太多类耦合在一起，免得修改系统中一部分，会影响到其他部分。如果许多类之间相互依赖，那么这个系统就会变成一个易碎的系统，它需要花许多成本维护，也会因为太复杂而不容易被其他人了解。

如何做到最少知识原则：1.如果某对象是调用其它方法的返回结果，不调用该对象的方法。

组件：想象成是被实例变量所引用的任何对象，即"has - a"关系。



# 第八章 模板方法模式

**模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。**（即把这些步骤的实现**延迟**到子类）。

**模板方法模式**在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。

这个模式是用来创建一个算法的模板。模板就是一个方法。这个方法将算法定义成一组步骤，其中的任何步骤都可以是抽象的，由子类负责实现。这可以确保算法的结构保持不变，同时由子类提供部分实现。

为防止子类改变模板方法中的算法，课件模板方法声明为final的。

**钩子**能够作为条件控制影响抽象类中的算法流程。

**钩子目的**：1.让子类实现算法中可选的部分，或者在钩子对于子类的实现并不重要的时候，子类可以对钩子置之不理。2.让子类能够有机会对模板方法中某些即将发生的（或刚刚发生的）步骤作出反应。

**好莱坞原则：**别调用我们，我们会调用你。（将决策权放在高层模块中，以便决定如何以及何时调用底层模块）

**Java API：**Arrays.sort()方法   InputStream类的read()方法  JFrame的paint()方法  Applet类的init()、start()、stop()、destroy()、paint()等

模板方法模式和策略模式的比较：

策略模式和模板方法模式都封装算法，一个用组合，一个用继承。

