# 第四章 工厂模式

**工厂方法模式**：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

所谓的“决定”，并不是指模式允许子类本身在运行时做决定，而是指在编写创建者类时，不需要知道实际创建的产品是哪一个。选择了哪个子类，自然就决定了实际创建产品是什么

**OO设计原则（依赖倒置原则）**：要依赖抽象，不要依赖具体类。

不能让**高层组件**（由其他低层组件定义其行为的类）依赖**底层组件**，而且，不管高层组件或底层组件，两者都应该依赖于抽象。

**抽象工厂模式**：抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是什么。这样一来，客户就从具体产品中被解耦。

**工厂方法模式和抽象工厂模式都是将对象创建的过程封装起来，以便将客户代码从具体类中解耦。**



# 第五章 单件模式

**单件模式**：确保一个类只有一个实例，并提供一个全局访问点

**延迟实例化（lazy instantiaze）**：如果我们不需要这个实例，它就永远不会产生，即懒汉式

**处理多线程：**只要把getInstance()变成同步(synchronized)方法，多线程灾难几乎可以轻易解决。

**改善多线程**：

1.如果getInstance()的性能对应用程序不是很关键，就什么都别做。

2.使用"急切"创建实例，而不用延迟实例化的做法，即饿汉式。在私有静态初始化器中创建单件，保证了**线程安全**。

3.用”双重检查加锁“，在getInstance()中减少使用同步：利用双重检查加锁，首先检查是否实例已经创建了，如果尚未创建，“才”进行同步，这样一来，只有第一次才会同步。这个做法可以大大减少getInstance()的时间耗费。

violatile关键词确保：当uniqueInstance变量被初始化成Singleton实例时，多个线程正确的处理uniqueInstance变量。

# 第六章 命令模式

**命令模式**：将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也支持可撤销的操作。